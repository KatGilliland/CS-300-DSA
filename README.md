# CS-300-DSA
# Name: Kat Gilliland

# What was the problem you were solving in the projects for this course?
Project one focused on developing an algorithmic design for an advising assistance software that will be offered by ABC University (ABCU) to allow its computer science students the ability to utilize a digital menu to complete tasks such as loading in the system’s data structure, printing out a full course list, searching for a specific course and printing that individual course’s information (title and if applicable, prerequisites), and exiting the program. ABCU tasked me with analyzing various data structures and using my analysis to provide a recommendation of which structure would be best suited for their desired program. Project two uses my data structure recommendation from project one to create the application. 

# How did you approach the problem? Consider why data structures are important to understand.
Data structures are crucial to understand because they dictate how a program will operate in terms of storing and retrieving data. While the usefulness of a particular data structure will depend on the type of program being built, they are vital to ensuring a system runs efficiently. An efficient program will have the ability to iterate through data as quickly as possible while consuming the least amount of memory. To approach the problem in project one, identifying which data structure would be most beneficial for ABCU’s advising assistance software, I developed pseudocode for three common data structures: vector, hash table, and tree. Each structure’s pseudocode outlines the software’s required functionalities such as the ability to open and read in data from a file, create objects to hold data from the input, and print course information using a digital menu. After designing all three structure’s pseudocode, I performed a Big-O analysis evaluating their run-time and memory capabilities. Based on this analysis and my breakdown of each structure’s cost per line, I determined that ABCU’s advising assistance software would benefit most from utilizing a vector data structure. Keeping this recommendation in mind, in project two, which asked me to design the code for the software, I referenced the vector data structure pseudocode delivered in project one. Using the vector data structure allowed me to create a functional tool for ABC University, according to their requirements, that runs as quickly as possible and uses the least amount of memory. 

# How did you overcome any roadblocks you encountered while going through the activities or project?
For project one, I overcame any roadblocks by referring to the snippets of pseudocode I had submitted in previous modules. Having the ability to revisit my instructor’s feedback and notes for improvement assisted me greatly in designing the three data structure pseudocodes and ensuring they met ABCU’s system requirements. I also used ZyBooks lessons from the course to my advantage by referencing any applicable lessons. For project two, this was only my second time loading in a text file and using that data within a program; to accomplish this portion of my code, I greatly benefited from watching YouTube videos of individuals working with text files in C++. 

# How has your work on this project expanded your approach to designing software and developing programs?
My work on these projects has given me a greater insight into why data structures are so important to software design and the development of programs. Data structures help organize data in the most logical way possible so that a program can perform as efficiently and effectively as possible. Without the proper data structure in place, a system is more prone to errors involving data accuracy and can end up being more costly for a business. These projects have also shown me the value of having well-written pseudocode. The pseudocode I wrote for project one helped me visualize how my final program would look and function before writing my code; this helped reduce the complexity of my code and gave me a foundation to start on when building out the program.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
My work on these projects has helped me write maintainable, readable, and adaptable code by pushing the importance of a well-thought-out structure. When code is organized and easy for another developer or individual working on the program to follow, it is much easier to modify or scale. As I continue to grow as a programmer, I will need to remind myself how vital it is to provide good documentation along with my work. 

